#!/usr/bin/env bash
# Default configuration
# shellcheck disable=all
# Project config values
PROJECT="Rosary In A Year (RIAY)"
# Turn on or turn off logging
LOGGING=false
# Set log level
# takes values notset, debug, info, warning, error and critical
LOGGING_LEVEL=debug
# The year in which the podcasts are being followed
# This ensures that the day of the week is aligned with the year
YEAR=2025

# commands file
COMMANDS_FILE="commands.txt"

# Github config values
REPO_OWNER=linusjf
REPO_NAME=RIAY

# overlay icon configuration
ICON_FILE="play-button.png"
ICON_SIZE="256x256"
ICON_OFFSET="+32+0"
ICON_COMMENT="Play Icon Added"

# add videos configuration
COMPACT_FILE="compact.txt"
VIDEOS_FILE="videos.txt"

# curl config values
# Time between successive requests to the LLM models
# This is to minimize triggering of rate limiting
GAP_BW_REQS=0
# Maximum number of retries for a REST API call
CURL_MAX_RETRIES=5
# The initial retry delay of 2 seconds which increases exponentially for each retry
CURL_INITIAL_RETRY_DELAY=2
# In curl, the --connect-timeout option sets how long (in seconds) to wait for the connection phase to the server to complete.
CURL_CONNECT_TIMEOUT=60
# --max-time in curl sets the maximum total time (in seconds) that the whole curl operation (connect + download/upload) is allowed to take.
CURL_MAX_TIME=60
# --the status codes for which retry can be attempted
CURL_RETRY_STATUS_CODES=(408 429 500 502 503 504)
# -- the status codes for which retry headers are to be read
CURL_RETRY_HEADER_STATUS_CODES=(429 503)

# Transcription config values
# whether to transcribe videos using a transcription service or rely on youtube auto-generated captions or creator provided subtitles
TRANSCRIBE_VIDEOS=false
# whether to transcribe locally or not
TRANSCRIBE_LOCALLY=false
# whether to use faster-whisper python library
USE_FASTER_WHISPER=true
# option whether to enable failover mode
ENABLE_FAILOVER_MODE=true

# Automatic Speech Recognition (ASR) LLM config values
# ASR API KEY
ASR_LLM_API_KEY="$DEEPINFRA_API_KEY"
# ASR LLM base url
ASR_LLM_BASE_URL="https://api.deepinfra.com/v1"
# ASR LLM endpoint
# use transcriptions end-point; faster than translations which requires language detection
ASR_LLM_ENDPOINT="/openai/audio/transcriptions"
# ASR LLM model used for transcriptions and translations
ASR_LLM_MODEL="openai/whisper-large-v3"
# ASR LLM model used locally while running whisper via command line
# valid values: tiny, base, small, medium, large, turbo
# as the names suggest memory requirements and parameters used increase as per the model size
# accuracy also improves as the model size increases
# https://github.com/openai/whisper?tab=readme-ov-file#available-models-and-languages
# Note that running ASR locally is several magnitudes slower than executing the web service
# the small model works best with beam_size 5 for accurate transcriptions.
# If you can live with a little inaccuracy, such as poco a poco mistranscribed, it doesn't matter
# since it is omitted by the subsequent summarization prompts, you could use the base model with beam-size 3 for quicker
# local transcriptions. For accuracy, the minimal best config is small with beam size 5
ASR_LOCAL_MODEL="small"
# initial prompt for whisper
ASR_INITIAL_PROMPT="In Ascension Press' Rosary in a Year podcast, Fr. Mark-Mary Ames meditates with sacred art, saint writings, and scripture. Poco a poco."
# carry initial prompt for whisper. whether the initial prompt should be used in decoding each segment
ASR_CARRY_INITIAL_PROMPT=true
# beam size for ASR
ASR_BEAM_SIZE=5

# youtube config values
# number of retries for yt-dlp when downloading captions
YT_DLP_RETRIES=20
# time to wait in seconds before giving up
YT_DLP_SOCKET_TIMEOUT=30
# captions output directory
CAPTIONS_OUTPUT_DIR="captions"

# AI Config values
# The temperature value to be set for the LLM models
# Set it to zero to ensure reproducibility for a model
TEMPERATURE=0.5

# text llm api key
TEXT_LLM_API_KEY="$DEEPINFRA_API_KEY"
# text llm base url
TEXT_LLM_BASE_URL="https://api.deepinfra.com/v1/openai"
# text llm chat model endpoint
TEXT_LLM_CHAT_ENDPOINT="/chat/completions"
# text llm model used for summarization
TEXT_LLM_MODEL="openai/gpt-oss-20b"

# The system prompt for summarizing text.
SYSTEM_SUMMARY_PROMPT="You are a helpful assistant that summarizes content. Be concise, helpful."
# The prompt for summarizing chunks within the podcast transcript.
CHUNK_SUMMARY_PROMPT='{
  "task": "Summarize the provided text.",
  "output_format": "Plain text summary in narrative style",
  "rules": {
    "exclude": [
      "plugs, branding, and promotions",
      "mentions of Day, podcast, and Rosary in a Day",
      "repetitive prayers such as Our Father, Hail Mary, and Glory Be"
    ],
    "include": [
      "details of any described artwork directly within the summary text"
    ]
  },
  "artwork_integration": "When artworks are described, naturally include their details (title, artist full name, current location, medium, style, date, and a brief description) as part of the flowing summary narrative."
}
'
CHUNK_SUMMARY_PROMPT="Summarize this text, excluding plugs, branding, and promotions. Avoid mention of Day, podcast and Rosary in a Day. Additionally, exclude repetitive prayers such as Our Father, Hail Mary and Glory Be. Include details of artwork decribed in the text including title, artist (full name), current location of artwork, medium, style, date (year, decade and century) and brief description."
# The prompt for the final summary of all the chunk summaries
FINAL_SUMMARY_PROMPT='{
  "task": "Summarize the provided text in the style of C.S. Lewis.",
  "output_format": "Markdown-formatted text",
  "format_requirements": {
    "header": "### AI-Generated Summary: {generated_title}",
    "generated_title": "string (title with proper grammar, no colon, concise yet reflective of the text)"
  },
  "style": {
    "voice": "C.S. Lewis",
    "tone": "gentle conviction, moral clarity, rhetorical flair",
    "audience": "intelligent but unassuming reader",
    "avoid": ["modern jargon", "meta-commentary", "footnotes", "explanations"]
  },
  "content_requirements": {
    "summary": "Clear, timeless presentation of ideas from the text",
    "artworks": "Include details of artworks if they are mentioned in the text",
    "restrictions": "Do not add explanations if artworks are not detailed"
  }
}
'
# The meta-prompt to generate image prompt and caption from the summary input
SUMMARY_IMAGE_META_PROMPT='You are an assistant that extracts visual meaning from text. Given any descriptive input, generate:
1. "image_prompt" - a detailed, visual description suitable for generating an abstract Christian art image in the styles of Vassily Kandinski and Mark Rothko using symbolic forms, non-literal shapes, and expressive textures. Let the composition prioritize emotion and interpretation over realism, with a color palette and structure that reflects the essence of the subject. Avoid depicting hands or feet and their digits.
2. "caption" - a brief, expressive caption that summarizes or enhances the image concept. No colons.
Return your response as a JSON object in the format: {"caption": "This is the generated caption", "image_prompt": "This is the image prompt"}.'
SUMMARY_ARTWORK_DETAILS_PROMPT='{
  "task": "Extract artwork details from the provided text.",
  "output_format": "JSON array of objects",
  "object_structure": {
    "details": {
      "title": "string (artwork title or empty string)",
      "artist": "string (artist name or empty string)",
      "date": "string (date of creation or empty string)",
      "medium": "string (artwork medium or empty string)",
      "style": "string (art style or empty string)",
      "location": "string (current location of artwork or empty string)",
      "subject": "string (main subject or empty string)"
    },
    "filename": "string (lowercase alphanumeric, max 20 chars, mostly unique, derived from title, artist, and date)",
    "caption": "string (caption in proper English, â‰¤20 words, must use title, artist, date, location, medium, subject in priority order)"
  },
  "rules": [
    "Each attribute in details must have a value or an empty string.",
    "If no artwork is described in the text, return an empty JSON array []."
  ]
}'
# Prompt for augmenting artwork details
ART_DETAILS_AUGMENT_PROMPT="You are a Christian art historian AI. Enhance the following JSON array objects with:
- original_title in the original language (if not present)
- title_language and ISO code
- a 20-word caption summarizing the artwork.
Return a well-formatted JSON array with the new fields added for each item in the array. Do not add any explanations."

# list of files for generating README and readthedocs documentation
# in the order below
CONTENT_DOCS=(
  "RIAY=start.md"
  "January=January.md"
  "February=February.md"
  "March=March.md"
  "April=April.md"
  "May=May.md"
  "June=June.md"
  "July=July.md"
  "August=August.md"
  "September=September.md"
  "October=October.md"
  "November=November.md"
  "December=December.md"
)

# image generation configuration
# turn on or off image generation
AUTO_GENERATE_IMAGES=false
# relative path to image generation script passed just one parameter --- the prompt ---
# and writing the path of the jpeg image generated to stdout
# you can plug in your own script here if you wish to use a different image generation engine and/or provider
IMAGE_GENERATION_SCRIPT="deepinfragenerateimage"
# deepinfra image generation inference model
DEEPINFRA_IMAGE_GENERATION_MODEL="stabilityai/sd3.5"
# falai image generation inference model
FALAI_IMAGE_GENERATION_MODEL="janus"

# art downloader configuration
AUTO_DOWNLOAD_ART=true
ART_DOWNLOADER_DIR="artdownloads"
MIN_IMAGE_WIDTH=350
MIN_IMAGE_HEIGHT=480
SEARCH_WIKIPEDIA=false
STOCK_PHOTO_SITES=(
  "alamy.com"
  "gettyimages.com"
  "gettyimages.co.uk"
  "istockphoto.com"
  "shutterstock.com"
  "dreamstime.com"
  "123rf.com"
  "depositphotos.com"
  "fineartamerica.com"
  "pixels.com"
  "bigstockphoto.com"
  "fotolia.com"
  "stock.adobe.com"
  "canstockphoto.com"
  "picfair.com"
  "granger.com"
  "bridgemanimages.com"
  "agefotostock.com"
  "europosters.nl"
  "nikkel-art.be"
  "etsy.com"
  "pixers.us"
  "ebayimg.com"
)
SOCIAL_MEDIA_SITES=(
  "reddit.com"
  "redd.it"
  "facebook.com"
  "X.com"
  "twitter.com"
  "tiktok.com"
  "threads.com"
  "snapchat.com"
  "linkedin.com"
  "pinterest.com"
  "quora.com"
  "tumblr.com"
  "4chan.com"
  "8kun.com"
  "imgur.com"
)
# config parameter whether to use art database or not
USE_ART_DATABASE=true

# art verifier settings
# parameter whether to verify art images or use rule-of-thumb where wikimedia images are preferred to images from google and duckduckgo
VERIFY_ART_IMAGES=true
# script that verifies art image
ART_VERIFIER_SCRIPT="matchimagetometadata.py"
# prompt to obtain art metadata
ART_METADATA_PROMPT="You are an expert on Christian art.
Provided the following details about the artwork '{}'
analyze the image and generate the following detailed metadata in json format (no markdown, no nesting of attributes, all top-level):
\"title\": The title of the artwork,
\"artist\": The artist or artists,
\"medium\": oil on canvas, fresco, marble sculpture, etc.,
\"location\": where the artwork is currently located,
\"date\": the creation year and century,
\"style\": the artistic style or artistic school that influenced the art,
\"description\": Description of the artwork (including visual elements, composition, subject matter, and style).
\"image_color\": Whether the image is in Color, Grayscale, Monochrome, Duotone/Tritone, Sepia,Color-tinted grayscale, Black-and-white etc.
\"watermarked\": Whether the image is watermarked or not.
\"caption\": A caption (in proper English), no more than 20 words, that uses title, artist, date, location, medium and description (in that ordered priority).
\"analyzed\": Whether the analysis was possible or not.
\"comments:\": Your comments other than the fields above and if analysis was possible or not and why.
Do not add any extraneous information that will mangle the json object expected."
# parameter to decide whether to allow rejected images to be embedded. Takes two values, strict or lenient
IMAGE_CONTENT_VALIDATION="lenient"
# vector embeddings model api key
VECTOR_EMBEDDINGS_MODEL_API_KEY="$DEEPINFRA_API_KEY"
# vector embeddings provider base url
VECTOR_EMBEDDINGS_BASE_URL="https://api.deepinfra.com/v1/openai"
# vector embeddings model used for cosine similarity
# if the model is used only to compare in memory
# you could use different models for production and test
# but if stored in file or database, use same models if files or databases shared
VECTOR_EMBEDDINGS_MODEL="thenlper/gte-large"
# vector embeddings model dimensions
VECTOR_EMBEDDINGS_MODEL_DIMENSIONS=1024
# Whether to look for alternate images using Google Lens
FIND_ALTERNATE_IMAGES=false

# config values for extractimagemetadata.py
# prompt to augment image metadata
AUGMENT_META_DATA_PROMPT="You are a Christian art historian AI. Enhance the following JSON array with:
- title
- artist
- date
- medium
- style
- current location of artwork (location)
- subject
- original_title in the original language (if not present)
- original_title_language and original_title_ISO_code
- a 30-word description summarizing the artwork.
for each item in the array.
Also, identify for each item in the array, what mystery of the Rosary (Joyful, Sorrowful, Luminous or Glorious) it fits into and the name of the mystery.
List of Rosary Mysteries:
Joyful Mysteries:
1. The Annunciation 2. The Visitation 3. The Nativity 4. The Presentation 5. The Finding in the Temple
Sorrowful Mysteries:
1. The Agony in the Garden 2. The Scourging at the Pillar 3. The Crowning with Thorns 4. The Carrying of the Cross 5. The Crucifixion
Glorious Mysteries:
1. The Resurrection 2. The Ascension 3. The Descent of the Holy Spirit 4. The Assumption of Mary 5. The Coronation of Mary
Luminous Mysteries:
1. The Baptism of Jesus in the Jordan 2. The Wedding at Cana 3. The Proclamation of the Kingdom of God 4. The Transfiguration 5. The Institution of the Eucharist
The additional field names are:
- mystery_type
- mystery_name
Return a JSON array with the new fields added wrapped in a field named 'artrecords'. Do not add any explanations. Fill values as empty string if you can't find any information."
# batch_size
AUGMENT_META_DATA_BATCH_SIZE=10

# config values for createartdb.py
# csv file that contains the extracted art records
ART_RECORDS_CSV="artrecords.csv"
# sqlite database name that has the art records
ART_DATABASE="art.db"
# hnsw index name that has the art records embeddings
ART_DATABASE_HNSW_INDEX="art.hnsw"
# hnsw database hnsw space
ART_DATABASE_HNSW_SPACE="cosine"
# hnsw database maximum results
ART_DATABASE_HNSW_MAX_RESULTS=3
# list of columns to embed from artrecords.csv
EMBEDDABLE_COLUMNS="artist,date,location,medium,mystery_name,mystery_type,original_title,style,subject,title,caption,description,image_filepath,image_url"
# identify mysteries of the rosary prompt
ROSARY_PROMPT="You are an expert in Christian theology and Catholic devotional practices, especially the Rosary.
You will be given a Christian text. Your task is to:
1. Identify whether it describes one or more of the 20 Mysteries of the Rosary.
2. Each identified mystery must be classified by:
- mystery_type: One of \"Joyful\", \"Sorrowful\", \"Glorious\", \"Luminous\".
- mystery_name: Exact name of the mystery.
3. If no mystery is described, return an empty JSON array ([]).
List of Rosary Mysteries:
Joyful Mysteries:
1. The Annunciation 2. The Visitation 3. The Nativity 4. The Presentation 5. The Finding in the Temple
Sorrowful Mysteries:
1. The Agony in the Garden 2. The Scourging at the Pillar 3. The Crowning with Thorns 4. The Carrying of the Cross 5. The Crucifixion
Glorious Mysteries:
1. The Resurrection 2. The Ascension 3. The Descent of the Holy Spirit 4. The Assumption of Mary 5. The Coronation of Mary
Luminous Mysteries:
1. The Baptism of Jesus in the Jordan 2. The Wedding at Cana 3. The Proclamation of the Kingdom of God 4. The Transfiguration 5. The Institution of the Eucharist
Output format: [{\"mystery_type\": \"Sorrowful\", \"mystery_name\": \"The Crucifixion\"}]
If no mysteries match, output: []
Do not provide any explanatory text.
Input text: {CHRISTIAN_TEXT}"
# create caption from json record and text input prompt
CREATE_CAPTION_PROMPT="Given two inputs: a json object with fields describing an art image and a text input which prescribes the art image, use your Christian art knowledge combined with the same to generate a descriptive caption for the art in 20 words or less:
JSON OBJECT:-
{json_object}
TEXT_INPUT:-
{text_input}
Return the caption only as text. Do not add any additional explanations.
"
