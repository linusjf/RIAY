#!/usr/bin/env bash

set -euo pipefail
shopt -s inherit_errexit

if [[ -z "${YOUTUBE_API_KEY:-}" || -z "${DEEPSEEK_API_KEY:-}" ]]; then
  echo "Error: YOUTUBE_API_KEY and/or DEEPSEEK_API_KEY environment variables not set."
  exit 1
fi

caption_only=false

while [[ $# -gt 0 ]]; do
  case "$1" in
    -c | --caption-only)
      caption_only=true
      shift
      ;;
    *) break ;;
  esac
done

VIDEO_ID="$1"

if [[ -z "$VIDEO_ID" ]]; then
  echo "Usage: $0 <youtube-video-id>"
  exit 1
fi

extract_text_from_vtt() {
  local vtt_file="$1"
  grep -vE '^[0-9]+$|^[0-9]{2}:' "$vtt_file" \
    | sed -e '/^WEBVTT/d' \
      -e '/^Kind/d' \
      -e '/^Language/d' \
      -e 's/\[Music\]//g' \
      -e '/^[[:space:]]*$/d' \
      -e 's/<[^>]*>//g' \
    | tr '\n' ' ' \
    | jq -Rs . | fold -s -w 1000 # escape double quotes and make file structured
}

# Fetch video title
VIDEO_TITLE=$(curl -s "https://www.googleapis.com/youtube/v3/videos?part=snippet&id=${VIDEO_ID}&key=${YOUTUBE_API_KEY}" \
  | jq -r '.items[0].snippet.title')

if [[ "$VIDEO_TITLE" == "null" ]]; then
  echo "Error: Could not fetch video title."
  exit 1
fi

# remove any prevuous subtitle and caption files
rm -f "${VIDEO_ID}.*"

# Download auto-subtitles using yt-dlp
yt-dlp --write-auto-sub --sub-lang "en" --skip-download --sub-format "vtt" \
  -o "${VIDEO_ID}.%(ext)s" "https://www.youtube.com/watch?v=${VIDEO_ID}" > /dev/null 2>&1

if [[ ! -f "${VIDEO_ID}.en.vtt" ]]; then
  echo "Error: Subtitle file not found."
  exit 1
fi

# Convert VTT to plain text
TRANSCRIPT=$(extract_text_from_vtt "${VIDEO_ID}.en.vtt")
# remove start and end quotes inserted by jq
TRANSCRIPT="${TRANSCRIPT:1:-1}"

if [[ -z "$TRANSCRIPT" ]]; then
  echo "Error: Transcript conversion failed."
  exit 1
fi

if "$caption_only"; then
  echo "$TRANSCRIPT" > "${VIDEO_ID}.en.txt"
  exit 0
fi

# Chunk transcript into 8000-character parts
CHUNK_SIZE=8000
TOTAL_LEN=${#TRANSCRIPT}
CHUNKS=()
for ((i = 0; i < TOTAL_LEN; i += CHUNK_SIZE)); do
  CHUNKS+=("${TRANSCRIPT:i:CHUNK_SIZE}")
done

# Function to summarize a single chunk
summarize_chunk() {
  local chunk="$1"
  local payload=''
  payload="$(
    cat << EOM
{
  "model": "deepseek-chat",
  "messages": [
    {
      "role": "system",
      "content": "You are a helpful assistant that summarizes YouTube transcripts. Exclude plugs, branding, and service/product promotions."
    },
    {
      "role": "user",
      "content": "Summarize this podcast transcript:\n\n${chunk}"
    }
  ],
  "temperature": 0.5
}
EOM
  )"
  local response="$(
    curl -s https://api.deepseek.com/chat/completions \
      -H "Authorization: Bearer ${DEEPSEEK_API_KEY}" \
      -H "Content-Type: application/json" \
      -d @- "${payload}"
  )"
  # Debug output if the JSON is invalid
  if ! echo "$response" | jq . > /dev/null 2>&1; then
    echo "ERROR: DeepSeek API returned invalid response:"
    echo "$response"
    exit 1
  fi
  echo "$response" | jq -r '.choices[0].message.content'
}

# Process each chunk
INTERMEDIATE_SUMMARIES=()
for chunk in "${CHUNKS[@]}"; do
  summary=$(summarize_chunk "$chunk")
  INTERMEDIATE_SUMMARIES+=("$summary")
done

# Final summarization step
FINAL_INPUT=$(printf "%s\n\n" "${INTERMEDIATE_SUMMARIES[@]}")

ESCAPED_INPUT=$(jq -Rs <<< "$FINAL_INPUT")

RESPONSE=$(
  curl -s https://api.deepseek.com/chat/completions \
    -H "Authorization: Bearer ${DEEPSEEK_API_KEY}" \
    -H "Content-Type: application/json" \
    -d @- << EOF
{
  "model": "deepseek-chat",
  "messages": [
    {
      "role": "system",
      "content": "Condense the following into a single, clean, human-readable summary. Exclude all promotional or branding references. Start with a level three header and annotate it as 'AI-Generated Summary:' followed by your generated title."
    },
    {
      "role": "user",
      "content": ${ESCAPED_INPUT}
    }
  ],
  "temperature": 0.5
}
EOF
)

# Debug output if the JSON is invalid
if ! echo "$RESPONSE" | jq . > /dev/null 2>&1; then
  echo "ERROR: DeepSeek API returned invalid response:"
  echo "$RESPONSE"
  exit 1
fi

FINAL_SUMMARY=$(echo "$RESPONSE" | jq -r '.choices[0].message.content')

# Output Markdown
echo -e "${FINAL_SUMMARY}"
