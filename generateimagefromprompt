#!/usr/bin/env bash
#
# Generate image from prompt using deepinfra API
#
# Usage: generateimagefromprompt /path/to/DayXXXImagePrompt.json
#        or
#        cat DayXXXImagePrompt.json | generateimagefromprompt
# Output: Creates /path/to/jpgs/DayXXXSummary.jpg

set -euo pipefail
shopt -s inherit_errexit

readonly VERSION="1.0.0"
readonly SCRIPT_NAME="$(basename "$0")"

### Functions ###

function version() {
  # Print script version
  # Globals: VERSION
  # Output: Version number to STDOUT
  # Returns: 0
  printf "%s\n" "$VERSION"
}

function usage() {
  # Print usage information
  # Globals: SCRIPT_NAME
  # Output: Usage message to STDOUT
  # Returns: 0
  cat << EOF
Usage: ${SCRIPT_NAME} [OPTIONS] [INPUT_FILE]

Options:
  -h, --help      Show this help message
  -v, --version   Show version information
  --verbose       Enable verbose output

Arguments:
  INPUT_FILE      Path to json prompt file (or read from stdin if not provided)

Example:
  ${SCRIPT_NAME} ./Day001ImagePrompt.json
  or
  cat Day001ImagePrompt.json | ${SCRIPT_NAME}
EOF
}

function extract_day_number() {
  # Extract day number from filename
  # Arguments: filename (string)
  # Output: Day number (string) to STDOUT
  # Returns: 0
  local filename="$1"
  local day_number
  day_number="$(echo "$filename" | sed -E 's/^Day([0-9]{3})ImagePrompt\.json$/\1/')"
  echo "$day_number"
}

function generate_temp_image() {
  # Generate temporary PNG image from prompt
  # Globals: None
  # Arguments: prompt (string), output_file (string)
  # Returns: 0 on success, non-zero on error
  local prompt="$1"
  local output_file="$2"

  deepctl infer -m "stabilityai/stable-diffusion-2-1" -i "prompt=${prompt}" \
    | sed 's/data:image\/png;base64,//' \
    | jq -r '.images[0]' \
    | base64 --decode > "$output_file"
}

function convert_to_jpg() {
  # Convert PNG to JPG
  # Globals: None
  # Arguments: png_file (string), jpg_file (string)
  # Returns: 0 on success, non-zero on error
  local png_file="$1"
  local jpg_file="$2"

  gm convert "$png_file" "$jpg_file"
}

function cleanup() {
  # Clean up temporary files
  # Globals: None
  # Arguments: files_to_remove (array)
  # Returns: 0
  local files=("$@")

  for file in "${files[@]}"; do
    if [[ -f "$file" ]]; then
      rm -f "$file"
    fi
  done
}

function read_input() {
  # Read input from file or stdin
  # Arguments: input_file (string) or empty for stdin
  # Output: File content to STDOUT
  # Returns: 0
  local inputfile="$1"
  if [[ -z "$inputfile" ]]; then
    cat
  else
    cat "$inputfile"
  fi
}

function get_output_dir() {
  # Get output directory path
  # Arguments: input_file (string) or empty for stdin
  # Output: Directory path to STDOUT
  # Returns: 0
  local inputfile="$1"
  if [[ -z "$inputfile" ]]; then
    echo "jpgs"
  else
    echo "$(dirname "$inputfile")/jpgs"
  fi
}

function get_filename_prefix() {
  # Get filename prefix
  # Arguments: input_file (string) or empty for stdin
  # Output: Filename prefix to STDOUT
  # Returns: 0
  local inputfile="$1"
  if [[ -z "$inputfile" ]]; then
    echo "Day000"
  else
    basename "$inputfile" | sed 's/ImagePrompt\.json//'
  fi
}

function main() {
  # Main execution function
  # Globals: SCRIPT_DIR
  # Arguments: input_file (string) or empty for stdin
  # Returns: 0 on success, non-zero on error
  local inputfile="${1:-}"
  local pngfile jpgfile summaryjpg json prompt caption day_number jpgfileprefix

  # Initialize variables
  pngfile="$(mktemp --quiet -t tempXXX.png)"
  json="$(read_input "$inputfile")"
  prompt="$(echo "$json" | jq -r '.image_prompt')"
  caption="$(echo "$json" | jq -r '.caption')"

  if [[ -n "$inputfile" ]]; then
    day_number="$(extract_day_number "$(basename "$inputfile")")"
    jpgfileprefix="$(basename "$inputfile" | sed 's/ImagePrompt\.json//')"
  else
    day_number="000"
    jpgfileprefix="Day000"
  fi

  # Generate and process images
  generate_temp_image "$prompt" "$pngfile"
  jpgfile="${pngfile%%.*}.jpg"
  convert_to_jpg "$pngfile" "$jpgfile"

  # Create output directory if needed
  output_dir="$(get_output_dir "$inputfile")"
  mkdir -p "$output_dir"

  # Save final image
  summaryjpg="${output_dir}/${jpgfileprefix}Summary.jpg"
  cp "$jpgfile" "$summaryjpg"

  # Add image to day
  "${SCRIPT_DIR}/addimgtoday" "$summaryjpg" "$caption" "$day_number"

  # Clean up
  cleanup "$pngfile" "$jpgfile"
}

### Main Execution ###

# Source utility libraries
readonly SCRIPT_DIR="$(cd "$(dirname "${BASH_SOURCE[0]}")" &> /dev/null && pwd -P)"
source "${SCRIPT_DIR}/lib/require.sh"
source "${SCRIPT_DIR}/lib/internet.sh"
source "${SCRIPT_DIR}/lib/util.sh"
source "${SCRIPT_DIR}/lib/curl.sh"
source "${SCRIPT_DIR}/lib/files.sh"
source "${SCRIPT_DIR}/lib/lockconfig.sh"
lockconfig::lock_config_vars "${SCRIPT_DIR}/config.env"

# Parse command line options
while [[ $# -gt 0 ]]; do
  case "$1" in
    -h | --help)
      usage
      exit 0
      ;;
    -v | --version)
      version
      exit 0
      ;;
    --verbose)
      export VERBOSE=true
      shift
      ;;
    *)
      break
      ;;
  esac
done

# Check required commands
require_commands jq tee cat deepctl base64 sed mktemp cp gm dirname basename

# Execute main function with logging if enabled
if [[ "${BASH_SOURCE[0]}" == "${0}" ]]; then
  if "${LOGGING:-false}"; then
    timestamp=$(date +"%Y%m%d_%H%M%S")
    {
      main "$@" 2> >(tee -a "${SCRIPT_NAME%.*}_${timestamp}.stderr.log" >&2)
    } | tee -a "${SCRIPT_NAME%.*}_${timestamp}.stdout.log"
  else
    main "$@"
  fi
fi
